"use strict";var j=Object.create;var m=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var G=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty;var H=(r,t)=>{for(var e in t)m(r,e,{get:t[e],enumerable:!0})},R=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of B(t))!K.call(r,a)&&a!==e&&m(r,a,{get:()=>t[a],enumerable:!(n=F(t,a))||n.enumerable});return r};var $=(r,t,e)=>(e=r!=null?j(G(r)):{},R(t||!r||!r.__esModule?m(e,"default",{value:r,enumerable:!0}):e,r)),J=r=>R(m({},"__esModule",{value:!0}),r);var ne={};H(ne,{default:()=>M});module.exports=J(ne);var A=require("@raycast/api");var f=$(require("react")),o=require("@raycast/api");var P=$(require("node:child_process")),C=require("node:buffer"),h=$(require("node:stream")),I=require("node:util");var O=require("react/jsx-runtime");var y=globalThis;var b=r=>!!r&&typeof r=="object"&&typeof r.removeListener=="function"&&typeof r.emit=="function"&&typeof r.reallyExit=="function"&&typeof r.listeners=="function"&&typeof r.kill=="function"&&typeof r.pid=="number"&&typeof r.on=="function",w=Symbol.for("signal-exit emitter"),x=class{constructor(){if(this.emitted={afterExit:!1,exit:!1},this.listeners={afterExit:[],exit:[]},this.count=0,this.id=Math.random(),y[w])return y[w];Object.defineProperty(y,w,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(t,e){this.listeners[t].push(e)}removeListener(t,e){let n=this.listeners[t],a=n.indexOf(e);a!==-1&&(a===0&&n.length===1?n.length=0:n.splice(a,1))}emit(t,e,n){if(this.emitted[t])return!1;this.emitted[t]=!0;let a=!1;for(let s of this.listeners[t])a=s(e,n)===!0||a;return t==="exit"&&(a=this.emit("afterExit",e,n)||a),a}},v=class{onExit(){return()=>{}}load(){}unload(){}},S=class{#o;#t;#e;#s;#i;#a;#n;#r;constructor(t){this.#o=process.platform==="win32"?"SIGINT":"SIGHUP",this.#t=new x,this.#a={},this.#n=!1,this.#r=[],this.#r.push("SIGHUP","SIGINT","SIGTERM"),globalThis.process.platform!=="win32"&&this.#r.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),globalThis.process.platform==="linux"&&this.#r.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT"),this.#e=t,this.#a={};for(let e of this.#r)this.#a[e]=()=>{let n=this.#e.listeners(e),{count:a}=this.#t,s=t;if(typeof s.__signal_exit_emitter__=="object"&&typeof s.__signal_exit_emitter__.count=="number"&&(a+=s.__signal_exit_emitter__.count),n.length===a){this.unload();let i=this.#t.emit("exit",null,e),c=e==="SIGHUP"?this.#o:e;i||t.kill(t.pid,c)}};this.#i=t.reallyExit,this.#s=t.emit}onExit(t,e){if(!b(this.#e))return()=>{};this.#n===!1&&this.load();let n=e?.alwaysLast?"afterExit":"exit";return this.#t.on(n,t),()=>{this.#t.removeListener(n,t),this.#t.listeners.exit.length===0&&this.#t.listeners.afterExit.length===0&&this.unload()}}load(){if(!this.#n){this.#n=!0,this.#t.count+=1;for(let t of this.#r)try{let e=this.#a[t];e&&this.#e.on(t,e)}catch{}this.#e.emit=(t,...e)=>this.#l(t,...e),this.#e.reallyExit=t=>this.#c(t)}}unload(){this.#n&&(this.#n=!1,this.#r.forEach(t=>{let e=this.#a[t];if(!e)throw new Error("Listener not defined for signal: "+t);try{this.#e.removeListener(t,e)}catch{}}),this.#e.emit=this.#s,this.#e.reallyExit=this.#i,this.#t.count-=1)}#c(t){return b(this.#e)?(this.#e.exitCode=t||0,this.#t.emit("exit",this.#e.exitCode,null),this.#i.call(this.#e,this.#e.exitCode)):0}#l(t,...e){let n=this.#s;if(t==="exit"&&b(this.#e)){typeof e[0]=="number"&&(this.#e.exitCode=e[0]);let a=n.call(this.#e,t,...e);return this.#t.emit("exit",this.#e.exitCode,null),a}else return n.call(this.#e,t,...e)}},k=null,Z=(r,t)=>(k||(k=b(process)?new S(process):new v),k.onExit(r,t));function q(r,{timeout:t}={}){let e=new Promise((c,l)=>{r.on("exit",(u,d)=>{c({exitCode:u,signal:d,timedOut:!1})}),r.on("error",u=>{l(u)}),r.stdin&&r.stdin.on("error",u=>{l(u)})}),n=Z(()=>{r.kill()});if(t===0||t===void 0)return e.finally(()=>n());let a,s=new Promise((c,l)=>{a=setTimeout(()=>{r.kill("SIGTERM"),l(Object.assign(new Error("Timed out"),{timedOut:!0,signal:"SIGTERM"}))},t)}),i=e.finally(()=>{clearTimeout(a)});return Promise.race([s,i]).finally(()=>n())}var E=class extends Error{constructor(){super("The output is too big"),this.name="MaxBufferError"}};function Y(r){let{encoding:t}=r,e=t==="buffer",n=new h.default.PassThrough({objectMode:!1});t&&t!=="buffer"&&n.setEncoding(t);let a=0,s=[];return n.on("data",i=>{s.push(i),a+=i.length}),n.getBufferedValue=()=>e?Buffer.concat(s,a):s.join(""),n.getBufferedLength=()=>a,n}async function _(r,t){let e=Y(t);return await new Promise((n,a)=>{let s=i=>{i&&e.getBufferedLength()<=C.constants.MAX_LENGTH&&(i.bufferedData=e.getBufferedValue()),a(i)};(async()=>{try{await(0,I.promisify)(h.default.pipeline)(r,e),n()}catch(i){s(i)}})(),e.on("data",()=>{e.getBufferedLength()>8e7&&s(new E)})}),e.getBufferedValue()}async function U(r,t){r.destroy();try{return await t}catch(e){return e.bufferedData}}async function X({stdout:r,stderr:t},{encoding:e},n){let a=_(r,{encoding:e}),s=_(t,{encoding:e});try{return await Promise.all([n,a,s])}catch(i){return Promise.all([{error:i,exitCode:null,signal:i.signal,timedOut:i.timedOut||!1},U(r,a),U(t,s)])}}function Q(r){let t=typeof r=="string"?`
`:10,e=typeof r=="string"?"\r":13;return r[r.length-1]===t&&(r=r.slice(0,-1)),r[r.length-1]===e&&(r=r.slice(0,-1)),r}function T(r,t){return r.stripFinalNewline?Q(t):t}function ee({timedOut:r,timeout:t,signal:e,exitCode:n}){return r?`timed out after ${t} milliseconds`:e!=null?`was killed with ${e}`:n!=null?`failed with exit code ${n}`:"failed"}function te({stdout:r,stderr:t,error:e,signal:n,exitCode:a,command:s,timedOut:i,options:c,parentError:l}){let d=`Command ${ee({timedOut:i,timeout:c?.timeout,signal:n,exitCode:a})}: ${s}`,p=e?`${d}
${e.message}`:d,g=[p,t,r].filter(Boolean).join(`
`);return e?e.originalMessage=e.message:e=l,e.message=g,e.shortMessage=p,e.command=s,e.exitCode=a,e.signal=n,e.stdout=r,e.stderr=t,"bufferedData"in e&&delete e.bufferedData,e}function re({stdout:r,stderr:t,error:e,exitCode:n,signal:a,timedOut:s,command:i,options:c,parentError:l}){if(e||n!==0||a!==null)throw te({error:e,exitCode:n,signal:a,stdout:r,stderr:t,command:i,timedOut:s,options:c,parentError:l});return r}async function L(r,t,e){if(process.platform!=="darwin")throw new Error("AppleScript is only supported on macOS");let{humanReadableOutput:n,language:a,timeout:s,...i}=Array.isArray(t)?e||{}:t||{},c=n!==!1?[]:["-ss"];a==="JavaScript"&&c.push("-l","JavaScript"),Array.isArray(t)&&c.push("-",...t);let l=P.default.spawn("osascript",c,{...i,env:{PATH:"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"}}),u=q(l,{timeout:s??1e4});l.stdin.end(r);let[{error:d,exitCode:p,signal:g,timedOut:D},W,z]=await X(l,{encoding:"utf8"},u),V=T({stripFinalNewline:!0},W),N=T({stripFinalNewline:!0},z);return re({stdout:V,stderr:N,error:d,exitCode:p,signal:g,timedOut:D,command:"osascript",options:e,parentError:new Error})}async function M(){await L(` 
  on getBackgroundSounds()
    try
      set currentSetting to do shell script "defaults read com.apple.ComfortSounds comfortSoundsEnabled"
      if currentSetting is equal to "1" then
        log "Background sound is on"
        return true
      else
        log "Background sound is off"
        return false
      end if
    on error
      return false
    end try
  end getBackgroundSounds
  
  on setBackgroundSounds(showRecents)
    if showRecents then
      do shell script "defaults write com.apple.ComfortSounds comfortSoundsEnabled -bool true; defaults write com.apple.ComfortSounds lastEnablementTimestamp $(date +%s)"
      log "Background sounds turned on"
    else
      do shell script "defaults write com.apple.ComfortSounds comfortSoundsEnabled -bool false"
      log "Background sounds turned off"
    end if
    do shell script "killall -HUP heard"
    getBackgroundSounds()
  end setBackgroundSounds
  
  if getBackgroundSounds() then
    setBackgroundSounds(false)
  else
    setBackgroundSounds(true)
  end if
`,[])?await(0,A.showHUD)("Background sound toggled"):await(0,A.showHUD)("Something went wrong. Please try again.")}
